// Code generated by go-codegen(https://github.com/nchern/go-codegen).
// You COULD edit this code it you really need it and know what are you doing

// Package hashmap provides a built-in implementation of a generic map
package main

import "sync"

// T0 is a generic type variable placeholder of a key type. It will not appear in the generated code

// T1 is a generic type variable placeholder of a value type. It will not appear in the generated code

// StringStringMapVisitor is a visitor function to visit map pairs
type StringStringMapVisitor func(string, string) bool

// StringStringMap exposes the contract of String to String map
type StringStringMap interface {
	// Each visits each element in the map. It stops iterations if visitor func returns false
	Each(visitor StringStringMapVisitor)

	// Get returns the value of a given key. If the key was not found the second return value will be false
	Get(key string) (v string, found bool)

	// Set sets the value of a given key
	Set(key string, val string)

	// Update updates the current map from a given map
	Update(src map[string]string) StringStringMap

	// Remove removes a given key from this map
	Remove(key string) bool

	// Clone creates a copy of this map
	Clone() StringStringMap
}

type baseStringStringMap struct {
	_map map[string]string
}

// NewStringStringMap creates a basic instance of the StringStringMap. It is _unsafe_ for concurrent access.
func NewStringStringMap() StringStringMap {
	res := &baseStringStringMap{
		_map: map[string]string{},
	}
	return res
}

// NewStringStringMapSyncronized creates a concurrent safe instance of the StringStringMap
func NewStringStringMapSyncronized() StringStringMap {
	return &syncStringStringMap{
		inner: NewStringStringMap(),
	}
}

func (m *baseStringStringMap) Get(key string) (v string, found bool) {
	v, found = m._map[key]
	return
}

func (m *baseStringStringMap) Each(visitor StringStringMapVisitor) {
	for k, v := range m._map {
		if !visitor(k, v) {
			return
		}
	}
}

func (m *baseStringStringMap) Set(key string, val string) {
	m._map[key] = val
}

func (m *baseStringStringMap) Update(src map[string]string) StringStringMap {
	for k, v := range src {
		m._map[k] = v
	}
	return m
}

func (m *baseStringStringMap) Remove(key string) bool {
	_, found := m._map[key]
	delete(m._map, key)

	return found
}

func (m *baseStringStringMap) Clone() StringStringMap {
	res := NewStringStringMap()
	for k, v := range m._map {
		res.Set(k, v)
	}

	return res
}

type syncStringStringMap struct {
	inner StringStringMap

	mutex sync.RWMutex
}

func (m *syncStringStringMap) Each(visitor StringStringMapVisitor) {
	m.mutex.RLock()
	m.inner.Each(visitor)
	m.mutex.RUnlock()
}

func (m *syncStringStringMap) Get(key string) (v string, found bool) {
	m.mutex.RLock()
	v, found = m.inner.Get(key)
	m.mutex.RUnlock()
	return
}

func (m *syncStringStringMap) Set(key string, val string) {
	m.mutex.Lock()
	m.inner.Set(key, val)
	m.mutex.Unlock()
}

func (m *syncStringStringMap) Update(src map[string]string) StringStringMap {
	m.mutex.Lock()
	m.inner.Update(src)
	m.mutex.Unlock()

	return m
}

func (m *syncStringStringMap) Remove(key string) bool {
	m.mutex.Lock()
	found := m.inner.Remove(key)
	m.mutex.Unlock()

	return found
}

func (m *syncStringStringMap) Clone() StringStringMap {
	m.mutex.RLock()
	r := m.inner.Clone()
	m.mutex.RUnlock()
	return r
}
