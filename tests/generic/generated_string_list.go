// Code generated by go-codegen(https://github.com/nchern/go-codegen).
// You COULD edit this code it you really need it and know what are you doing

// Package list provides a built-in implementation of a generic list
package main

import (
	"sort"
	"sync"
)

// T0 is a generic type variable placeholder of a key type. It will not appear in the generated code

// StringPredicate is a predicate function on String type
type StringPredicate func(string) bool

// StringVisitor is a visitor function used to visit items of the list
type StringVisitor func(i int, val string) bool

// StringLessFunc is a comparator function used to sort the list
type StringLessFunc func(first, second string) bool

// StringList exposes a contract of a list of String elements
type StringList interface {
	// Filter returns a new list filled with items that are yielded true on given predicate
	Filter(f StringPredicate) StringList

	// IFilter is similar to Filter but returns a channel instead of a StringList instance
	IFilter(f StringPredicate) <-chan string

	// Iter return a channel that is filled with this list elements
	Iter() <-chan string

	// Each visits each element in the map. It stops iterations if visitor func returns false
	Each(visitor StringVisitor) StringList

	// Get returns i-th element from this list
	Get(i int) string

	Any(f StringPredicate) bool
	All(f StringPredicate) bool
	FindFirst(f StringPredicate, defaultVal string) string
	FindLast(f StringPredicate, defaultVal string) string
	Len() int
	Swap(i, j int)
	Sort(byFunc StringLessFunc) StringList
	Clone() StringList
	Set(i int, val string)
	Append(items ...string)
	Prepend(items ...string)
	Pop(defaultVal string) string
}

type baseStringList struct {
	list []string
}

// NewStringList creates an empty list of String elements
func NewStringList() StringList {
	return NewStringListFromSlice([]string{}...)
}

// NewStringListFromSlice creates a list of String element initialised from a given slice
func NewStringListFromSlice(items ...string) StringList {
	l := make([]string, len(items))
	copy(l, items)
	return &baseStringList{list: l}
}

// NewSyncronizedStringList creates a concurrent safe instance of a StringList
func NewSyncronizedStringList(items ...string) StringList {
	l := make([]string, len(items))
	copy(l, items)
	inner := &baseStringList{list: l}
	return &syncStringList{inner: inner}
}

func (l *baseStringList) Filter(f StringPredicate) StringList {
	result := &baseStringList{list: []string{}}
	for _, v := range l.list {
		if f(v) {
			result.list = append(result.list, v)
		}
	}
	return result
}

func (l *baseStringList) IFilter(f StringPredicate) <-chan string {
	results := make(chan string)
	go func() {
		for _, v := range l.list {
			if f(v) {
				results <- v
			}
		}
		close(results)
	}()

	return results
}

func (l *baseStringList) Iter() <-chan string {
	results := make(chan string)
	go func() {
		for _, v := range l.list {
			results <- v
		}
		close(results)
	}()

	return results
}

func (l *baseStringList) Each(visitor StringVisitor) StringList {
	for i, v := range l.list {
		if !visitor(i, v) {
			return l
		}
	}
	return l
}

func (l *baseStringList) Get(i int) string {
	return l.list[i]
}

func (l *baseStringList) Any(f StringPredicate) bool {
	for _, v := range l.list {
		if f(v) {
			return true
		}
	}
	return false
}

func (l *baseStringList) All(f StringPredicate) bool {
	for _, v := range l.list {
		if !f(v) {
			return false
		}
	}
	return true
}

func (l *baseStringList) FindFirst(f StringPredicate, defaultVal string) string {
	for _, v := range l.list {
		if f(v) {
			return v
		}
	}
	return defaultVal
}

func (l *baseStringList) FindLast(f StringPredicate, defaultVal string) string {
	found := defaultVal
	for _, v := range l.list {
		if f(v) {
			found = v
		}
	}
	return found
}

// For sort

func (l *baseStringList) Len() int {
	return len(l.list)
}

func (l *baseStringList) Swap(i, j int) {
	l.list[i], l.list[j] = l.list[j], l.list[i]
}

func (l *baseStringList) Sort(byFunc StringLessFunc) StringList {
	sorter := &byFuncStringSorter{l, byFunc}
	sort.Sort(sorter)

	return l
}

func (l *baseStringList) Clone() StringList {
	copied := make([]string, len(l.list))
	copy(copied, l.list)

	r := NewStringListFromSlice(copied...)

	return r
}

// Mutators

func (l *baseStringList) Set(i int, val string) {
	l.list[i] = val
}

func (l *baseStringList) Append(items ...string) {
	l.list = append(l.list, items...)
}

func (l *baseStringList) Prepend(items ...string) {
	l.list = append(items, l.list...)
}

func (l *baseStringList) Pop(defaultVal string) string {
	if len(l.list) < 1 {
		return defaultVal
	}

	result := l.list[len(l.list)-1]

	l.list = l.list[:len(l.list)-1]

	return result
}

// PopRight

type byFuncStringSorter struct {
	*baseStringList
	lessFn StringLessFunc
}

func (s *byFuncStringSorter) Less(i, j int) bool {
	return s.lessFn(s.list[i], s.list[j])
}

type syncStringList struct {
	inner *baseStringList

	mutex sync.RWMutex
}

func (l *syncStringList) Filter(f StringPredicate) StringList {
	l.mutex.RLock()
	r := l.inner.Filter(f)
	l.mutex.RUnlock()
	return r
}

func (l *syncStringList) IFilter(f StringPredicate) <-chan string {
	results := make(chan string)
	go func() {
		l.mutex.RLock()
		for _, v := range l.inner.list {
			if f(v) {
				results <- v
			}
		}
		l.mutex.RUnlock()
		close(results)
	}()

	return results
}

func (l *syncStringList) Iter() <-chan string {
	results := make(chan string)
	go func() {
		l.mutex.RLock()
		for _, v := range l.inner.list {
			results <- v
		}
		l.mutex.RUnlock()
		close(results)
	}()

	return results
}

func (l *syncStringList) Each(visitor StringVisitor) StringList {
	l.mutex.RLock()
	l.inner.Each(visitor)
	l.mutex.RUnlock()
	return l
}

func (l *syncStringList) Get(i int) string {
	l.mutex.RLock()
	v := l.inner.Get(i)
	l.mutex.RUnlock()
	return v
}

func (l *syncStringList) Any(f StringPredicate) bool {
	l.mutex.RLock()
	r := l.inner.Any(f)
	l.mutex.RUnlock()
	return r
}

func (l *syncStringList) All(f StringPredicate) bool {
	l.mutex.RLock()
	r := l.inner.All(f)
	l.mutex.RUnlock()
	return r
}

func (l *syncStringList) FindFirst(f StringPredicate, defaultVal string) string {
	l.mutex.RLock()
	r := l.inner.FindFirst(f, defaultVal)
	l.mutex.RUnlock()
	return r
}

func (l *syncStringList) FindLast(f StringPredicate, defaultVal string) string {
	l.mutex.RLock()
	r := l.inner.FindLast(f, defaultVal)
	l.mutex.RUnlock()
	return r
}

func (l *syncStringList) Len() int {
	l.mutex.RLock()
	r := l.inner.Len()
	l.mutex.RUnlock()
	return r
}

func (l *syncStringList) Swap(i int, j int) {
	l.mutex.Lock()
	l.inner.Swap(i, j)
	l.mutex.Unlock()
}

func (l *syncStringList) Sort(byFunc StringLessFunc) StringList {
	l.mutex.Lock()
	l.inner.Sort(byFunc)
	l.mutex.Unlock()
	return l
}

func (l *syncStringList) Clone() StringList {
	l.mutex.RLock()
	r := l.inner.Clone()
	l.mutex.RUnlock()
	return r
}

func (l *syncStringList) Set(i int, val string) {
	l.mutex.Lock()
	l.inner.Set(i, val)
	l.mutex.Unlock()
}

func (l *syncStringList) Append(items ...string) {
	l.mutex.Lock()
	l.inner.Append(items...)
	l.mutex.Unlock()
}

func (l *syncStringList) Prepend(items ...string) {
	l.mutex.Lock()
	l.inner.Prepend(items...)
	l.mutex.Unlock()
}

func (l *syncStringList) Pop(defaultVal string) string {
	l.mutex.Lock()
	r := l.inner.Pop(defaultVal)
	l.mutex.Unlock()
	return r
}
