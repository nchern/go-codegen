package main

import (
	"log"
	"os"

	"github.com/nchern/go-codegen/code"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

var (
	params = &code.CommonParams{}

	enabledGenerators = []code.Generator{
		&code.MapGenerator{},
		&code.ListGenerator{},
	}
)

func init() {
	log.SetFlags(0)
}

func failOnError(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func cobraCommandsFromGenerators(cmds []code.Generator) []*cobra.Command {
	results := []*cobra.Command{}
	for _, gen := range cmds {
		cobraCmd := &cobra.Command{}
		cobraCmd.Use, cobraCmd.Short = gen.Cmd()
		g := gen
		cobraCmd.Run = func(cmd *cobra.Command, args []string) {
			failOnError(code.Generate(g, params, args))
		}
		results = append(results, cobraCmd)
	}
	return results
}

func main() {

	pflag.BoolVar(&params.IsSync, "sync", false, "if a generated type should be thread-safe")
	flagSync := pflag.Lookup("sync")

	pflag.StringVar(&params.Name, "name", "Autogenerated", "name of a generated type ")
	flagName := pflag.Lookup("name")

	pflag.StringVar(&params.PkgName, "pkg", "", "golang package name. Package directive is not generated if this param is empty")
	flagPkgName := pflag.Lookup("pkg")

	rootCmd := &cobra.Command{
		Use:  "go-codegen",
		Long: "Go code generation tool.",
	}
	rootCmd.Flags().AddFlag(flagName)
	rootCmd.Flags().AddFlag(flagSync)
	rootCmd.Flags().AddFlag(flagPkgName)

	rootCmd.AddCommand(cobraCommandsFromGenerators(enabledGenerators)...)

	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}

}
